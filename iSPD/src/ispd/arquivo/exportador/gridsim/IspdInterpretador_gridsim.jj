
options {
  STATIC = false;
}

PARSER_BEGIN(Interpretador)

package ispd.arquivo.exportador.gridsim;

import CarregaArqTexto.MostraSaida;
import javax.swing.*;
import javax.swing.filechooser.*;
import java.awt.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.awt.image.*;  
import java.net.*;  
import javax.imageio.*;
import java.awt.*;
import java.util.HashSet;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;
import java.io.*;

class Interpretador{

	public boolean verbose;
	private String textoVerbose = "Saida do Verbose:";
	public boolean erroEncontrado = false;
	private HashSet<Interpretador.DescreveIconePrivado> listaIcones = new HashSet<Interpretador.DescreveIconePrivado>();
	private HashSet<String> listaNomes = new HashSet<String>();
	private HashSet<String> listaEscravos = new HashSet<String>();
	private HashSet<String> listaConexoes = new HashSet<String>();
	private List<String> escravos2 = new ArrayList<String>();
	private String proprietario = null;
	private String algoritmo = null;
	private String erros = "Erros encontrados durante o parser do Modelo Iconico:";
	private int numIcones = 0;
	private int numArestas = 0;
	private int numVertices = 0;
	private Boolean cargasConfiguradas = new Boolean(false);;
	private Integer cargasTipoConfiguracao = new Integer(-1);
	private String cargasConfiguracao = new String();
	private int numeroConexoes = 0;
        private int tam_comp = 0;
        private int tam_comm = 0;
        private int num_tarefas = 0;
	
	public Interpretador(){
	}

	public void printv(String msg){
		textoVerbose = textoVerbose+"\n>"+msg;
	}

	public void addErro(String msg){
		erros = erros+"\n"+msg;
	}

	public void resuladoParser(){
		if(erroEncontrado){
			MostraSaida saida = new MostraSaida("Found Errors",erros);
			saida.setVisible(true);
		}
		else{
			//JOptionPane.showOptionDialog(null,"Modelo iconico reconhecido com sucesso","Arquivo Reconhecido", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null);
			if(verbose){ MostraSaida saida = new MostraSaida("Saida do Reconhecimento",textoVerbose); saida.setVisible(true); }
		}
	}

	public void verificaLabels(){
		for(String temp:listaEscravos){
			if(!listaNomes.contains(temp)){
				erroEncontrado = true;
				addErro("\'"+temp+"\' does not exist!");
			}
		}
		for(String temp:listaConexoes){
			if(!listaNomes.contains(temp)){
				erroEncontrado = true;
				addErro("\'"+temp+"\' does not exist!");
			}
		}
	}

	public void escreveArquivo(){
            int i=0, j=0; //i,j => contadores
            try{
			File file = new File("ModeloGridSim");
			FileWriter writer = new FileWriter(file);
			PrintWriter saida = new PrintWriter(writer,true);
			/*-------------------------------------------------------------------------------------------------------------*/
                        saida.println("import java.util.*; \n import java.Calendar.*; \n import java.gridsim.*; \n import gridsim.net.*;");
			saida.println("class Modelo \n {");
                        saida.println("public static void main(String[] args) {");
                        saida.println("try {");
                        saida.println("Calendar calendar = Calendar.getInstance();");
                        saida.println("String[] exclude_from_file = {\"\"}; \n String[] exclude_from_processing = {\"\"};");
                        saida.println("GridSim.init(0, calendar, true, exclude_from_file,exclude_from_processing, null);");
                        saida.println("MachineList mList = new MachineList();");
			
			//encontrar totalresourse é nº total de recursos
			saida.println("ArrayList resList = new ArrayList(totalResource);");
			for(Interpretador.DescreveIconePrivado icone:listaIcones){ //O recurso é uma só máquina.
                                if(icone.getTipoIcone()==1) //Icone é um nó(1)
                                {       saida.println("mList"+i+".add( new Machine("+ i +",1,"+ icone.getPoderComputacional()+"));");  
	                                saida.println("ResourceCharacteristics resConfig"+i+" = new ResourceCharacteristics(\"Sun Ultra\",\"Solaris\" , mList"+i+", ResourceCharacteristics.TIME_SHARED, 0, 0);");
					saida.println("GridResource "+ icone.getNome() +" = new GridResource(\"name\" , baud_rate, seed, resConfig"+i+", 0.0 , 0.0, 0.0, Weekends,Holidays);"); 
					saida.println("resList.add( "+ icone.getNome() +");");
					
					saida.println("Router "+icone.getNome()+" = new RIPRouter(router"+i+", trace_flag);");
					saida.println("FIFOScheduler resSched = new FIFOScheduler(GridResSched_"+i+");");
                			saida.println(icone.getNome() +".attachHost("+icone.getNome()+", resSched); "); //nome roteador igual ao recurso		
					i++;
					
                                }        
                        } 
			
			for(Interpretador.DescreveIconePrivado icone:listaIcones){ //O recurso é homogeneo, .
				int k;                                
				if(icone.getTipoIcone()==3) //Icone é um cluster(1)
                                {       for(k=0; k< icone.getNumeroEscravos(); k++)
					saida.println("mList"+j+".add( new Machine("+ k +",1,"+ icone.getPoderComputacional()+"));");
					
					saida.println("ResourceCharacteristics resConfig"+j+" = new ResourceCharacteristics(\"Sun Ultra\",\"Solaris\" , mList"+j+", ResourceCharacteristics.TIME_SHARED, 0, 0);");
					saida.println("GridResource "+ icone.getNome() +" = new GridResource(\"name\" , baud_rate, seed, resConfig"+j+", 0.0 , 0.0, 0.0, Weekends,Holidays);");     
					saida.println("resList.add( "+ icone.getNome() +");");
					
					saida.println("Router "+icone.getNome()+" = new RIPRouter("+icone.getNome()+", trace_flag);");//nome roteador igual ao recurso
					saida.println("FIFOScheduler resSched = new FIFOScheduler(GridResSched_"+i+");");
                			saida.println(icone.getNome()+".attachHost("+icone.getNome()+", resSched);");
			                        	
				}	
			} 

                            
                        saida.println("LinkedList<Integer> Weekends = new LinkedList<Integer>(); \n Weekends.add(new Integer(Calendar.SATURDAY)); \n Weekends.add(new Integer(Calendar.SUNDAY)); \n LinkedList<Integer> Holidays = new LinkedList<Integer>();");
                        saida.println("seed=11L*13*17*19*23+1;");    
                        
			saida.println(" GridletList list = new GridletList();");
                        for( i=0; i < num_tarefas; i++)
                        {   if(cargasTipoConfiguracao==0 || cargasTipoConfiguracao==1 ) //Se carga for do tipo Random ou por máquina
                            {   saida.println("Gridlet gridlet"+i+" = new Gridlet("+ i +", "+ tam_comp +", "+ tam_comm * 125000 +", "+ tam_comm * 125000 +");"); //tam_comp em MI, tam_comm está em Mbits é necessário a conversão para bytes.
                                saida.println("list.add(gridlet"+i+");");
                            }   
                        }
                        
			//user jto com comunicação entre grilets
						
			totalGridlet = num_tarefas;			

			saida.println("ArrayList userList = new ArrayList(num_user);");
			saida.println("for (i = 0; i < num_user; i++) ");
			saida.println("{");
				// if trace_flag is set to "true", then this experiment will
				// create User_i.csv where i = 0 ... (num_user-1)
			saida.println("	NetUser user = new NetUser(User_"+i+", "+totalGridlet+", baud_rate, propDelay, mtu, trace_flag); ");

				// add a user into a list
			saida.println("	userList.add(user); ");
			saida.println("}");

			saida.println(" NetUser obj = null;");
			saida.println("for (i = 0; i < userList.size(); i++)");
			saida.println("{");
			saida.println("	FIFOScheduler userSched = new FIFOScheduler(NetUserSched_"+i+"); ");
			saida.println("	obj = (NetUser) userList.get(i);");
			saida.println("	r_u"+i+".attachHost(obj, userSched); } ");


			saida.println("FIFOScheduler rSched = new FIFOScheduler(\"r_Sched\");"); 
			
			for(Interpretador.DescreveIconePrivado icone:listaIcones){                               
				if(icone.getTipoIcone()==2) //Icone é um link(2)
                                {	saida.println("Link "+ icone.getNome()  +" = new SimpleLink("+ icone.getNome() + ", "+ icone.getBanda() * 1000000 +", "+ icone.getLatencia() * (10^(-3))+", "+icone.getBanda() *0.1 +");"); 
					saida.println(icone.getNoOrigem()+".attachRouter("+icone.getNoDestino+", link, rSched, rSched);"); 						
				}                       	

			}

			saida.println("GridSim.startGridSimulation();");

			saida.println("} ");
			saida.println("	catch (Exception e) ");
			saida.println(" { ");
			saida.println("  e.printStackTrace(); ");
			saida.println("  System.out.println(\"Unwanted errors happen\"); ");
        		saida.println(" }");
   				 			
			saida.println(" }");
			
			saida.println("class NetUser extends GridSim"); //classe para usuario, 
			saida.println("	{ ");
   			saida.println("	 private int myId_;    ");  // my entity ID
    			saida.println("	 private String name_;  "); // my entity name
    			saida.println("	 private GridletList list_;     ");     // list of submitted Gridlets
    			saida.println("	 private GridletList receiveList_; ");   // list of received Gridlets
    			saida.println("	 private SimReport report_;");
			saida.println(" NetUser(String name, int totalGridlet, double baud_rate, double delay,int MTU, boolean trace_flag) throws Exception { super( name, new SimpleLink(name+\"_link\",baud_rate,delay, MTU) ); this.name_ = name; this.receiveList_ = new GridletList(); this.list_ = new GridletList();if (trace_flag == true) {     report_ = new SimReport(name); } this.myId_ = super.getEntityId(name); this.createGridlet(myId_, totalGridlet); } ");
			
			//linca o usuario com sua tarefa, falta colocar os parametros
			saida.println(" public GridletList getGridletList() {  ");
			saida.println("	return receiveList_; ");
			saida.println("	} ");

						    /**
						     * This method will show you how to create Gridlets
						     * @param userID        owner ID of a Gridlet
						     * @param numGridlet    number of Gridlet to be created
						     */
			saida.println("	private void createGridlet(int userID, int numGridlet) ");
			saida.println("	{ ");
			/*
							int data = 5000;
							for (int i = 0; i < numGridlet; i++)
							{
							    // Creates a Gridlet
							    Gridlet gl = new Gridlet(i, data, data, data);
							    gl.setUserID(userID);

							    // add this gridlet into a list
							    this.list_.add(gl);
							}
						 } 
						public void body()
						    {
							// wait for a little while for about 3 seconds.
							// This to give a time for GridResource entities to register their
							// services to GIS (GridInformationService) entity.
							super.gridSimHold(3.0);
							LinkedList resList = super.getGridResourceList();

							// initialises all the containers
							int totalResource = resList.size();
							int resourceID[] = new int[totalResource];
							String resourceName[] = new String[totalResource];

							// a loop to get all the resources available
							int i = 0;
							for (i = 0; i < totalResource; i++)
							{
							    // Resource list contains list of resource IDs
							    resourceID[i] = ( (Integer) resList.get(i) ).intValue();

							    // get their names as well
							    resourceName[i] = GridSim.getEntityName( resourceID[i] );
							}

							////////////////////////////////////////////////
							// SUBMIT Gridlets

							// determines which GridResource to send to
							int index = myId_ % totalResource;
							if (index >= totalResource) {
							    index = 0;
							}

							// sends all the Gridlets
							Gridlet gl = null;
							boolean success;
							for (i = 0; i < list_.size(); i++)
							{
							    gl = (Gridlet) list_.get(i);
							    write(name_ + "Sending Gridlet #" + i + " to " + resourceName[index]);

							    // For even number of Gridlets, send without an acknowledgement
							    // whether a resource has received them or not.
							    if (i % 2 == 0)
							    {
								// by default - send without an ack
								success = super.gridletSubmit(gl, resourceID[index]);
							    }

							    // For odd number of Gridlets, send with an acknowledgement
							    else
							    {
								// this is a blocking call
								success = super.gridletSubmit(gl,resourceID[index],0.0,true);
								write("ack = " + success + " for Gridlet #" + i);
							    }
							}

							////////////////////////////////////////////////////////
							// RECEIVES Gridlets back

							// hold for few period - few seconds since the Gridlets length are
							// quite huge for a small bandwidth
							super.gridSimHold(5);

							// receives the gridlet back
							for (i = 0; i < list_.size(); i++)
							{
							    gl = (Gridlet) super.receiveEventObject();  // gets the Gridlet
							    receiveList_.add(gl);   // add into the received list

							    write(name_ + ": Receiving Gridlet #" +
								  gl.getGridletID() + " at time = " + GridSim.clock() );
							}

							////////////////////////////////////////////////////////
							// ping functionality
							InfoPacket pkt = null;
							int size = 500;

							// There are 2 ways to ping an entity:
							// a. non-blocking call, i.e.
							//super.ping(resourceID[index], size);    // (i)   ping
							//super.gridSimHold(10);        // (ii)  do something else
							//pkt = super.getPingResult();  // (iii) get the result back

							// b. blocking call, i.e. ping and wait for a result
							pkt = super.pingBlockingCall(resourceID[index], size);

							// print the result
							write("\n-------- " + name_ + " ----------------");
							write(pkt.toString());
							write("-------- " + name_ + " ----------------\n");

							////////////////////////////////////////////////////////
							// shut down I/O ports
							shutdownUserEntity();
							terminateIOEntities();

							// don't forget to close the file
							if (report_ != null) {
							    report_.finalWrite();
							}

							write(this.name_ + ": sending and receiving of Gridlets" + " complete at " + GridSim.clock() ); */
			saida.println("} ");
                        
                        
                        
                        /*---------------------------------------------------------------------------------------------------------*/
			saida.close();   
			writer.close();
			//JOptionPane.showMessageDialog(null,"File successfully saved\n","Completed",JOptionPane.INFORMATION_MESSAGE);
		}
		// em caso de erro apresenta mensagem abaixo  
		catch(Exception e){  
			JOptionPane.showMessageDialog(null,e.getMessage(),"Warning",JOptionPane.WARNING_MESSAGE);  
		}
		
		
	}

	public void consomeTokens(){
		Token t = getToken(1);
		while( t.kind != MAQ && t.kind != REDE && t.kind != INET && t.kind != CLUSTER && t.kind != CARGA && t.kind != EOF){
			getNextToken();
			t = getToken(1);
		}
	}

	public void resetaObjetosParser(){
		textoVerbose = "";
		erroEncontrado = false;
		listaIcones.clear();
		numIcones = 0;
		numVertices = 0;
		numArestas = 0;
		listaNomes.clear();
		listaEscravos.clear();
		listaConexoes.clear();
		escravos2.clear();
		String algoritmo = null;
		String erros = "Foram encontrados os seguintes erros durante o parser:";
		cargasConfiguradas = new Boolean(false);;
		cargasTipoConfiguracao = new Integer(-1);
		cargasConfiguracao = new String();	
		numeroConexoes = 0;
		tam_comp = 0;
        	tam_comm = 0;
        	num_tarefas = 0;		
	}
	
	private class DescreveIconePrivado {

			private int tipoIcone;
                        private String proprietario;
			private int IdGlobal;
			private int IdLocal;
			private String nome;
			private int x,y,prex,prey;
			private double poderComputacional;
			private double taxaOcupacao;
			private double latencia;
			private double banda;
			private int numeroEscravos;
			private boolean mestre;
			private String algoritmoEscalonamento;
			private List<String> escravos;
			private List<Integer> escravos2;
			private int noOrigem;
			private int noDestino;
			private String snoOrigem;
			private String snoDestino;
			private HashSet<Integer> conexaoEntrada;
			private HashSet<Integer> conexaoSaida;

			public DescreveIconePrivado(){
				conexaoEntrada = new HashSet<Integer>();
				conexaoSaida = new HashSet<Integer>();
			}
			public void setAtributosNo(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double taxaOcupacao,boolean mestre,String algoritmoEscalonamento,List<String> escravos){
				escravos2 = new ArrayList<Integer>();
				this.tipoIcone = tipoIcone;
				this.IdLocal = IdLocal;
				this.IdGlobal = IdGlobal;
				this.nome = nome;
				this.x = 0;
				this.y = 0;
				this.prex = 0;
				this.prey = 0;
				this.poderComputacional = poderComputacional;
				this.taxaOcupacao = taxaOcupacao;
				this.latencia = 0.0;
				this.banda = 0.0;
				this.mestre = mestre;
				this.escravos = escravos;
				this.algoritmoEscalonamento = algoritmoEscalonamento;
				this.numeroEscravos = 0;
				this.noOrigem = 0;
				this.noDestino = 0;
				this.snoOrigem = null;
				this.snoDestino = null;
			}
			public void setAtributosLink(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda,String snoOrigem, String snoDestino){
				escravos2 = new ArrayList<Integer>();
				this.tipoIcone = tipoIcone;
				this.IdLocal = IdLocal;
				this.IdGlobal = IdGlobal;
				this.nome = nome;
				this.x = 0;
				this.y = 0;
				this.prex = 0;
				this.prey = 0;
				this.poderComputacional = 0.0;
				this.taxaOcupacao = taxaOcupacao;
				this.latencia = latencia;
				this.banda = banda;
				this.mestre = false;
				this.escravos = new ArrayList<String>();
				this.algoritmoEscalonamento = null;
				this.numeroEscravos = 0;
				this.noOrigem = 0;
				this.noDestino = 0;
				this.snoOrigem = snoOrigem;
				this.snoDestino = snoDestino;
			}
			public void setAtributosCluster(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double latencia,double banda, String algoritmoEscalonamento, int numeroEscravos){
				escravos2 = new ArrayList<Integer>();
				this.tipoIcone = tipoIcone;
				this.IdLocal = IdLocal;
				this.IdGlobal = IdGlobal;
				this.nome = nome;
				this.x = 0;
				this.y = 0;
				this.prex = 0;
				this.prey = 0;
				this.poderComputacional = poderComputacional;
				this.taxaOcupacao = 0.0;
				this.latencia = latencia;
				this.banda = banda;
				this.mestre = false;
				this.escravos = new ArrayList<String>();
				this.algoritmoEscalonamento = algoritmoEscalonamento;
				this.numeroEscravos = numeroEscravos;
				this.noOrigem = 0;
				this.noDestino = 0;
				this.snoOrigem = null;
				this.snoDestino = null;
			}
			public void setAtributosInet(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda){
				escravos2 = new ArrayList<Integer>();
				this.tipoIcone = tipoIcone;
				this.IdLocal = IdLocal;
				this.IdGlobal = IdGlobal;
				this.nome = nome;
				this.x = 0;
				this.y = 0;
				this.prex = 0;
				this.prey = 0;
				this.poderComputacional = 0.0;
				this.taxaOcupacao = taxaOcupacao;
				this.latencia = latencia;
				this.banda = banda;
				this.mestre = false;
				this.escravos = new ArrayList<String>();
				this.algoritmoEscalonamento = null;
				this.numeroEscravos = 0;
				this.noOrigem = 0;
				this.noDestino = 0;
				this.snoOrigem = null;
				this.snoDestino = null;
			}

                        public void setProprietario(String nome){proprietario=nome;}
			public void addConexaoEntrada(int num){conexaoEntrada.add(num);}
			public void addConexaoSaida(int num){conexaoSaida.add(num);}
			public void addEscravos2(int id){escravos2.add(id);}
			public int getTipoIcone(){return  tipoIcone;}
			public int getIdGlobal(){return  IdGlobal;}
			public int getIdLocal(){return  IdLocal;}
			public String getNome(){return  nome;}
			public int getNumX(){return  x;}
			public int getNumY(){return  y;}
			public void setX(int x){this.x = x;}
			public void setY(int y){this.y = y;}
			public int getNumPreX(){return  prex;}
			public int getNumPreY(){return  prey;}
			public void setPreX(int x){this.prex = x;}
			public void setPreY(int y){this.prey = y;}
			public double getPoderComputacional(){return  poderComputacional;}
			public double getTaxaOcupacao(){return  taxaOcupacao;}
			public double getLatencia(){return  latencia;}
			public double getBanda(){return  banda;}
			public boolean getMestre(){return  mestre;}
			public List<String> getEscravos(){return  escravos;}
			public List<Integer> getEscravos2(){return  escravos2;}
			public String getAlgoritmo(){return  algoritmoEscalonamento;}
			public int getNumeroEscravos(){return numeroEscravos;}
			public void setNoOrigem(int no){this.noOrigem = no;}
			public void setNoDestino(int no){this.noDestino = no;}
			public int getNoOrigem(){return noOrigem;}
			public int getNoDestino(){return noDestino;}
			public String getSNoOrigem(){return snoOrigem;}
			public String getSNoDestino(){return snoDestino;}
			public HashSet<Integer> getConexaoEntrada(){return conexaoEntrada;}
			public HashSet<Integer> getConexaoSaida(){return conexaoSaida;}
	}
}
PARSER_END(Interpretador)



TOKEN_MGR_DECLS:
{
private int contaErrosLex = 0;
private String erros = new String("");


public int encontrouErroLex()
{
	return contaErrosLex;
}

public void addErro(String msg)
{
	erros = erros+"\n"+msg;
}

public String getErros()
{
	return erros;
}

}


TOKEN:	{ 
	<RR: "RoundRobin"> |
	<MAQ: "MAQ"> |
	<VAZIO: "---"> |
	<LMAQ: "LMAQ"> |
	<REDE: "REDE"> |
	<INET: "INET"> |
	<FPLTF:	"FPLTF"> |
	<CARGA: "CARGA"> |
	<TRACE: "TRACE"> |
	<MESTRE: "MESTRE"> |
	<RANDOM: "RANDOM"> |
	<POISSON: "POISSON"> |
	<ESCRAVO: "ESCRAVO"> |
	<CLUSTER: "CLUSTER"> |
	<CONECTA: "CONECTA"> |
	<MAQUINA: "MAQUINA"> |
	<TWOSTAGE: "TWOSTAGE"> |
	<WORKQUEUE: "WORKQUEUE"> |
	<EXPONENCIAL: "EXPONENCIAL">
	} 
//strings mais curtas antes para melhorar o desempenho do lexer

TOKEN:	{< especial: ( "!" | "@" | "#" | "$" | "%" | "&" | "(" | ")" | "-" | "_" | "+" | "=" | "{" | "}" | "[" | "]" | "~" | "^" | ";" | "." | "," | "|" | ":" | "\\" | "/" ) >}

TOKEN:	{< nome: (["A"-"Z","a"-"z"])+((<especial>) | (["0"-"9"]) | (["A"-"Z","a"-"z"]))* >}

TOKEN:	{< inteiro: (["0"-"9"])+ >}

TOKEN:	{< flutuante: (["0"-"9"])+"."(["0"-"9"])+ >}

SKIP: { "\n" | " " | "\t" | "\b" | < "#" (~["\r","\n"])* ("\n" | "\r" | "\r\n") > }

SPECIAL_TOKEN:
{
<invalido: (~["A"-"Z","a"-"z","0"-"9","!" , "@" , "#" , "$" , "%" , "&" , "(" , ")" , "-" , "_" , "+" , "=" , "{" , "}" , "[" , "]" , "~" , "^" , ";" , "." , "," , "|" , ":" , "\\" , "/", "\n" , " " , "\t" , "\b" , "#" ])+>
	{
		addErro("Erro na linha "+input_stream.getEndLine()+". Caracter "+image+" não é aceito.");
		contaErrosLex++;
	}
}


void Modelo():
{
	resetaObjetosParser();
 }
{
	try{
		Icones() <EOF> 
		{
			printv("Reconheceu Modelo()");
	
			verificaLabels();	
	
			resuladoParser();
		}
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
		resuladoParser();
	}
}

void Icones():
{

}
{
	 (Icone())+ 
		{ printv("Reconheceu Icones"); }
}

void Icone():
{

}
{
	No()	
		{ printv("Reconheceu No()"); }
	| Cluster() 
		{ printv("Reconheceu Cluster()"); }
	| Link()
		{ printv("Reconheceu Link()"); }
	| Inet()
		{ printv("Reconheceu Inet()"); }
	| Carga()
		{ printv("Reconheceu Carga()"); }
}

boolean NoTipo():
{
	Token t;
}
{

	<MESTRE> algoritmo=ClusterAlg() <LMAQ> NoLista() { return true; }
	| <ESCRAVO> { return false; }
}

boolean TipoUsuario():
{
        Token t;
        Boolean mestre;
}
{
        t=<nome> mestre=NoTipo() { proprietario = t.image; return mestre; } |
        mestre=NoTipo() { proprietario = null; return mestre; }
}


void NoLista():
{
	Token t;
	String s;
	escravos2.clear();
}
{
	(t=<nome>{s = t.image; escravos2.add(s); listaEscravos.add(s); printv("Reconheceu nome no escravo");} )+
}

void No():
{
	Boolean mestre;
	Token t2, t3, t4;
	DescreveIconePrivado icone = new DescreveIconePrivado();
	List<String> escravos = new ArrayList<String>();
}
{
	try{
		<MAQ> t2=<nome> t3=<flutuante> t4=<flutuante> mestre=TipoUsuario()
		{
			icone.setProprietario(proprietario);
                        if(listaNomes.contains(t2.image)){
				addErro("There's already an icon named \'"+t2.image+"\'.");
				erroEncontrado = true;
			}else{
				listaNomes.add(t2.image);
			}
		
			if(mestre){icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), true, algoritmo, escravos2);
					listaIcones.add(icone); 
					numIcones++;
					numVertices++;
					algoritmo = null;
				}
			else{icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), false, algoritmo, escravos);
					listaIcones.add(icone); 
					numIcones++;
					numVertices++;
				}
		}
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
	}

}

void Link():
{
	Token t2, t3, t4, t5, t6, t7;
	DescreveIconePrivado icone = new DescreveIconePrivado();
}
{
	try{
		<REDE> t2=<nome> t3=<flutuante> t4=<flutuante> t5=<flutuante> <CONECTA> t6=<nome> t7=<nome>
		{
			if(listaNomes.contains(t2.image)){
				addErro("There's already an icon named \'"+t2.image+"\'.");
				erroEncontrado = true;
			}else{
				listaNomes.add(t2.image);
			}
			
			if(!listaConexoes.contains(t6.image)){ listaConexoes.add(t6.image); }
			if(!listaConexoes.contains(t7.image)){ listaConexoes.add(t7.image); }
			icone.setAtributosLink(2, numArestas, numIcones , t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image), t6.image, t7.image);
			listaIcones.add(icone);
			numArestas++;
			numIcones++;
			numeroConexoes++;
		}
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
	}
}

String ClusterAlg():
{
	Token t;
	String s;
}
{
	t=<RR> { s = t.image; return s;}
	| t=<WORKQUEUE> { s = t.image; return s;}
	| t=<FPLTF> { s = t.image; return s;}
	| t=<VAZIO> { s = t.image; return s;}
}

String TipoUsuarioCluster():
{
        Token t;
        String alg;
}
{
        t=<nome> alg=ClusterAlg() { proprietario = t.image; return alg; } |
        alg=ClusterAlg() { proprietario = null; return alg; }
}

void Cluster():
{
	String s;
	Token t2, t3, t4, t5, t6, t7;
	DescreveIconePrivado icone = new DescreveIconePrivado();
}
{
	try{
		<CLUSTER> t2=<nome> t3=<inteiro> t4=<flutuante> t5=<flutuante> t6=<flutuante> s=TipoUsuarioCluster()
		{
                        icone.setProprietario(proprietario);
			if(listaNomes.contains(t2.image)){
				addErro("There's already an icon named \'"+t2.image+"\'.");
				erroEncontrado = true;
			}else{
				listaNomes.add(t2.image);
			}
			icone.setAtributosCluster(3, numVertices, numIcones, t2.image, Double.parseDouble(t4.image), Double.parseDouble(t6.image), Double.parseDouble(t5.image), s,  Integer.parseInt(t3.image));
			listaIcones.add(icone);
			numIcones++;
			numVertices++;
		}
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
	}
}

void Inet():
{
	Token t2, t3, t4, t5, t6, t7;
	DescreveIconePrivado icone = new DescreveIconePrivado();
	//escravos.clear();
	HashSet<String> nosConectados = new HashSet<String>();
	List<String> escravos = new ArrayList<String>();
}
{
	try{
		<INET> t2=<nome> t3=<flutuante> t4=<flutuante> t5=<flutuante>
		{	
			if(listaNomes.contains(t2.image)){
				addErro("There's already an icon named \'"+t2.image+"\'.");
				erroEncontrado = true;
			}else{
				listaNomes.add(t2.image);
			}
			icone.setAtributosInet(4, numVertices,numIcones, t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image));
			listaIcones.add(icone);
			numIcones++;
			numVertices++;
		}
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
	}
}

void Carga():
{
	cargasConfiguradas = true;
}
{
	try{
		<CARGA> TipoCarga()
	}
	catch(ParseException e){
		Token t = getToken(1);
		addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
		erroEncontrado = true;
		consomeTokens();
	}
}

void TipoCarga():
{
}
{
		<RANDOM> TipoRandom()
	|	<MAQUINA> (TipoMaquina())+
	|	<TRACE> TipoTrace()
}

void TipoRandom():
{
	String dist;
	Token t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11;
	cargasTipoConfiguracao = 0;
	num_tarefas = 0;
        tam_comp = 0;
        tam_comm = 0;
}
{
	t1=<inteiro> t2=<inteiro> t3=<inteiro> t4=<flutuante> t5=<inteiro> t6=<inteiro> t7=<inteiro> t8=<flutuante> t9=<inteiro> t10=<inteiro> t11=<inteiro> 
	{
		cargasConfiguracao = t1.image+" "+t2.image+" "+t3.image+" "+t4.image+"\n"+t5.image+" "+t6.image+" "+t7.image+" "+t8.image+"\n"+t9.image+" "+t10.image+" "+t11.image;
		num_tarefas = Integer.parseInt(t11.image);
                tam_comp = Integer.parseInt(t2.image);
                tam_comm = Integer.parseInt(t6.image);	
	}
}

String Distribuicao():
{
	Token t;
}
{
		t=<POISSON> {return t.image;} 
	|	t=<EXPONENCIAL> {return t.image;}
	|	t=<TWOSTAGE> {return t.image;}
}

void TipoMaquina():
{
	String dist;
	Token t1,t2,t3,t4,t5,t6;
	cargasTipoConfiguracao = 1;
	num_tarefas = 0;
        tam_comp = 0;
        tam_comm = 0;
}
{
	t1=<nome> t2=<inteiro> t3=<flutuante> t4=<flutuante> t5=<flutuante> t6=<flutuante>
	{
		cargasConfiguracao += ""+t1.image+" "+t2.image+" "+t3.image+" "+t4.image+" "+t5.image+" "+t6.image+"\n";
		num_tarefas = Integer.parseInt(t2.image);
                tam_comp = Integer.parseInt(t3.image);
                tam_comm = Integer.parseInt(t5.image);
	}
}

void TipoTrace():
{
	Token t;
	cargasTipoConfiguracao = 2;
}
{
	t=<nome>
	{
		cargasConfiguracao = t.image+"\n";
	}
}
