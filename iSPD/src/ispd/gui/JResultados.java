/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * JResultados.java
 *
 * Created on 20/09/2011, 11:01:42
 */
package ispd.gui;

import ispd.motor.filas.RedeDeFilas;
import ispd.motor.filas.Tarefa;
import ispd.motor.filas.servidores.CS_Comunicacao;
import ispd.motor.filas.servidores.CS_Processamento;
import ispd.motor.metricas.MetricasGlobais;
import ispd.motor.metricas.MetricasUsuarios;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.labels.StandardXYToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYStepAreaRenderer;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

/**
 *
 * @author denison_usuario
 */
public class JResultados extends javax.swing.JDialog {

    /**
     * Creates new form JResultados
     */
    public JResultados(java.awt.Frame parent, RedeDeFilas rdf, List tarefas) {
        super(parent, true);
        gerarGraficosProcessamento(rdf);
        gerarGraficosComunicacao(rdf);
        tabelaRecurso = setTabelaRecurso(rdf);
        initComponents();
        this.jTextAreaGlobal.setText(getResultadosGlobais(rdf.getMetricasGlobais()));
        this.jTextAreaTarefa.setText(getResultadosTarefas(tarefas));
        setResultadosUsuario(rdf.getMetricasUsuarios());

        graficoProcessamentoTempo = new ChartPanel(criarGraficoProcessamentoTempo(rdf));
        graficoProcessamentoTempo.setPreferredSize(new Dimension(600, 300));
        if (rdf.getMaquinas().size() > 20) {
            this.jButtonProcessamentoMaquina.setVisible(false);
        }
        if (tarefas.size() < 50) {
            graficoProcessamentoTempoTarefa = new ChartPanel(criarGraficoProcessamentoTempoTarefa(tarefas));
            graficoProcessamentoTempoTarefa.setPreferredSize(new Dimension(600, 300));
        } else {
            this.jButtonProcessamentoTarefa.setVisible(false);
        }

        graficoProcessamentoTempoUser = new ChartPanel(criarGraficoProcessamentoTempoUser(tarefas, rdf));
        graficoProcessamentoTempoUser.setPreferredSize(new Dimension(600, 300));

        this.jScrollPaneProcessamento.setViewportView(this.graficoBarraProcessamento);
        this.jScrollPaneComunicacao.setViewportView(this.graficoBarraComunicacao);
        this.jScrollPaneProcessamentoTempo.setViewportView(this.graficoProcessamentoTempo);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane1 = new javax.swing.JTabbedPane();
        jScrollPaneGobal = new javax.swing.JScrollPane();
        jTextAreaGlobal = new javax.swing.JTextArea();
        jScrollPaneTarefa = new javax.swing.JScrollPane();
        jTextAreaTarefa = new javax.swing.JTextArea();
        jScrollPaneUsuario = new javax.swing.JScrollPane();
        jTextAreaUsuario = new javax.swing.JTextArea();
        jScrollPaneRecurso = new javax.swing.JScrollPane();
        Object[] colunas = {"Label", "Owner", "Processing performed", "Communication performed"};
        jTableRecurso = new javax.swing.JTable();
        jPanelProcessamento = new javax.swing.JPanel();
        jToolBarProcessamento = new javax.swing.JToolBar();
        jButtonPBarra = new javax.swing.JButton();
        jButtonPPizza = new javax.swing.JButton();
        jScrollPaneProcessamento = new javax.swing.JScrollPane();
        jPanelComunicacao = new javax.swing.JPanel();
        jToolBarComunicacao = new javax.swing.JToolBar();
        jButtonCBarra = new javax.swing.JButton();
        jButtonCPizza = new javax.swing.JButton();
        jScrollPaneComunicacao = new javax.swing.JScrollPane();
        jPanelProcessamentoTempo = new javax.swing.JPanel();
        jToolBarProcessamentoTempo = new javax.swing.JToolBar();
        jButtonProcessamentoUser = new javax.swing.JButton();
        jButtonProcessamentoMaquina = new javax.swing.JButton();
        jButtonProcessamentoTarefa = new javax.swing.JButton();
        jScrollPaneProcessamentoTempo = new javax.swing.JScrollPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Simulation Results");

        jTextAreaGlobal.setEditable(false);
        jTextAreaGlobal.setColumns(20);
        jTextAreaGlobal.setFont(new java.awt.Font("Courier New", 1, 14)); // NOI18N
        jTextAreaGlobal.setRows(5);
        jScrollPaneGobal.setViewportView(jTextAreaGlobal);

        jTabbedPane1.addTab("Global", jScrollPaneGobal);

        jTextAreaTarefa.setColumns(20);
        jTextAreaTarefa.setEditable(false);
        jTextAreaTarefa.setFont(new java.awt.Font("Courier New", 0, 14)); // NOI18N
        jTextAreaTarefa.setRows(5);
        jScrollPaneTarefa.setViewportView(jTextAreaTarefa);

        jTabbedPane1.addTab("Tasks", jScrollPaneTarefa);

        jTextAreaUsuario.setColumns(20);
        jTextAreaUsuario.setEditable(false);
        jTextAreaUsuario.setFont(new java.awt.Font("Courier New", 0, 14)); // NOI18N
        jTextAreaUsuario.setRows(5);
        jScrollPaneUsuario.setViewportView(jTextAreaUsuario);

        jTabbedPane1.addTab("User", jScrollPaneUsuario);

        jTableRecurso.setModel(new javax.swing.table.DefaultTableModel(tabelaRecurso,colunas));
        jScrollPaneRecurso.setViewportView(jTableRecurso);

        jTabbedPane1.addTab("Resources", jScrollPaneRecurso);

        jToolBarProcessamento.setRollover(true);

        jButtonPBarra.setText("Bar Chart");
        jButtonPBarra.setFocusable(false);
        jButtonPBarra.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonPBarra.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonPBarra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPBarraActionPerformed(evt);
            }
        });
        jToolBarProcessamento.add(jButtonPBarra);

        jButtonPPizza.setText("Pie chart");
        jButtonPPizza.setFocusable(false);
        jButtonPPizza.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonPPizza.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonPPizza.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPPizzaActionPerformed(evt);
            }
        });
        jToolBarProcessamento.add(jButtonPPizza);

        javax.swing.GroupLayout jPanelProcessamentoLayout = new javax.swing.GroupLayout(jPanelProcessamento);
        jPanelProcessamento.setLayout(jPanelProcessamentoLayout);
        jPanelProcessamentoLayout.setHorizontalGroup(
            jPanelProcessamentoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBarProcessamento, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
            .addComponent(jScrollPaneProcessamento, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
        );
        jPanelProcessamentoLayout.setVerticalGroup(
            jPanelProcessamentoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelProcessamentoLayout.createSequentialGroup()
                .addComponent(jToolBarProcessamento, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPaneProcessamento, javax.swing.GroupLayout.DEFAULT_SIZE, 310, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Chart of the processing", jPanelProcessamento);

        jToolBarComunicacao.setRollover(true);

        jButtonCBarra.setText("Bar Chart");
        jButtonCBarra.setFocusable(false);
        jButtonCBarra.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonCBarra.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonCBarra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCBarraActionPerformed(evt);
            }
        });
        jToolBarComunicacao.add(jButtonCBarra);

        jButtonCPizza.setText("Pie chart");
        jButtonCPizza.setFocusable(false);
        jButtonCPizza.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonCPizza.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonCPizza.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCPizzaActionPerformed(evt);
            }
        });
        jToolBarComunicacao.add(jButtonCPizza);

        javax.swing.GroupLayout jPanelComunicacaoLayout = new javax.swing.GroupLayout(jPanelComunicacao);
        jPanelComunicacao.setLayout(jPanelComunicacaoLayout);
        jPanelComunicacaoLayout.setHorizontalGroup(
            jPanelComunicacaoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBarComunicacao, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
            .addComponent(jScrollPaneComunicacao, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
        );
        jPanelComunicacaoLayout.setVerticalGroup(
            jPanelComunicacaoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelComunicacaoLayout.createSequentialGroup()
                .addComponent(jToolBarComunicacao, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPaneComunicacao, javax.swing.GroupLayout.DEFAULT_SIZE, 310, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Chart of the communication", jPanelComunicacao);

        jToolBarProcessamentoTempo.setRollover(true);

        jButtonProcessamentoUser.setText("Per user");
        jButtonProcessamentoUser.setFocusable(false);
        jButtonProcessamentoUser.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonProcessamentoUser.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonProcessamentoUser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonProcessamentoUserActionPerformed(evt);
            }
        });
        jToolBarProcessamentoTempo.add(jButtonProcessamentoUser);

        jButtonProcessamentoMaquina.setText("Per machine");
        jButtonProcessamentoMaquina.setFocusable(false);
        jButtonProcessamentoMaquina.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonProcessamentoMaquina.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonProcessamentoMaquina.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonProcessamentoMaquinaActionPerformed(evt);
            }
        });
        jToolBarProcessamentoTempo.add(jButtonProcessamentoMaquina);

        jButtonProcessamentoTarefa.setText("Per task");
        jButtonProcessamentoTarefa.setFocusable(false);
        jButtonProcessamentoTarefa.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonProcessamentoTarefa.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonProcessamentoTarefa.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonProcessamentoTarefaActionPerformed(evt);
            }
        });
        jToolBarProcessamentoTempo.add(jButtonProcessamentoTarefa);

        javax.swing.GroupLayout jPanelProcessamentoTempoLayout = new javax.swing.GroupLayout(jPanelProcessamentoTempo);
        jPanelProcessamentoTempo.setLayout(jPanelProcessamentoTempoLayout);
        jPanelProcessamentoTempoLayout.setHorizontalGroup(
            jPanelProcessamentoTempoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBarProcessamentoTempo, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
            .addComponent(jScrollPaneProcessamentoTempo, javax.swing.GroupLayout.DEFAULT_SIZE, 627, Short.MAX_VALUE)
        );
        jPanelProcessamentoTempoLayout.setVerticalGroup(
            jPanelProcessamentoTempoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelProcessamentoTempoLayout.createSequentialGroup()
                .addComponent(jToolBarProcessamentoTempo, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPaneProcessamentoTempo, javax.swing.GroupLayout.DEFAULT_SIZE, 310, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Use of computing power through time", jPanelProcessamentoTempo);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 386, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCPizzaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCPizzaActionPerformed
        // TODO add your handling code here:
        this.jScrollPaneComunicacao.setViewportView(this.graficoPizzaComunicacao);
    }//GEN-LAST:event_jButtonCPizzaActionPerformed

    private void jButtonCBarraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCBarraActionPerformed
        // TODO add your handling code here:
        this.jScrollPaneComunicacao.setViewportView(this.graficoBarraComunicacao);
    }//GEN-LAST:event_jButtonCBarraActionPerformed

    private void jButtonPPizzaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPPizzaActionPerformed
        // TODO add your handling code here:
        this.jScrollPaneProcessamento.setViewportView(this.graficoPizzaProcessamento);
    }//GEN-LAST:event_jButtonPPizzaActionPerformed

    private void jButtonPBarraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPBarraActionPerformed
        // TODO add your handling code here:
        this.jScrollPaneProcessamento.setViewportView(this.graficoBarraProcessamento);
    }//GEN-LAST:event_jButtonPBarraActionPerformed

    private void jButtonProcessamentoMaquinaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonProcessamentoMaquinaActionPerformed
        this.jScrollPaneProcessamentoTempo.setViewportView(this.graficoProcessamentoTempo);
    }//GEN-LAST:event_jButtonProcessamentoMaquinaActionPerformed

    private void jButtonProcessamentoTarefaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonProcessamentoTarefaActionPerformed
        this.jScrollPaneProcessamentoTempo.setViewportView(this.graficoProcessamentoTempoTarefa);
    }//GEN-LAST:event_jButtonProcessamentoTarefaActionPerformed

    private void jButtonProcessamentoUserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonProcessamentoUserActionPerformed
        this.jScrollPaneProcessamentoTempo.setViewportView(this.graficoProcessamentoTempoUser);
    }//GEN-LAST:event_jButtonProcessamentoUserActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonCBarra;
    private javax.swing.JButton jButtonCPizza;
    private javax.swing.JButton jButtonPBarra;
    private javax.swing.JButton jButtonPPizza;
    private javax.swing.JButton jButtonProcessamentoMaquina;
    private javax.swing.JButton jButtonProcessamentoTarefa;
    private javax.swing.JButton jButtonProcessamentoUser;
    private javax.swing.JPanel jPanelComunicacao;
    private javax.swing.JPanel jPanelProcessamento;
    private javax.swing.JPanel jPanelProcessamentoTempo;
    private javax.swing.JScrollPane jScrollPaneComunicacao;
    private javax.swing.JScrollPane jScrollPaneGobal;
    private javax.swing.JScrollPane jScrollPaneProcessamento;
    private javax.swing.JScrollPane jScrollPaneProcessamentoTempo;
    private javax.swing.JScrollPane jScrollPaneRecurso;
    private javax.swing.JScrollPane jScrollPaneTarefa;
    private javax.swing.JScrollPane jScrollPaneUsuario;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jTableRecurso;
    private javax.swing.JTextArea jTextAreaGlobal;
    private javax.swing.JTextArea jTextAreaTarefa;
    private javax.swing.JTextArea jTextAreaUsuario;
    private javax.swing.JToolBar jToolBarComunicacao;
    private javax.swing.JToolBar jToolBarProcessamento;
    private javax.swing.JToolBar jToolBarProcessamentoTempo;
    // End of variables declaration//GEN-END:variables
    private Object[][] tabelaRecurso;
    private ChartPanel graficoBarraProcessamento;
    private ChartPanel graficoBarraComunicacao;
    private ChartPanel graficoPizzaProcessamento;
    private ChartPanel graficoPizzaComunicacao;
    private ChartPanel graficoProcessamentoTempo;
    private ChartPanel graficoProcessamentoTempoTarefa;
    private ChartPanel graficoProcessamentoTempoUser;
    private double poderComputacionalTotal = 0;

    private String getResultadosGlobais(MetricasGlobais globais) {
        String texto = "\t\tSimulation Results\n\n";
        texto += String.format("\tTotal Simulated Time = %g \n", globais.getTempoSimulacao());
        texto += String.format("\tSatisfaction = %g %%\n", globais.getSatisfacaoMedia());
        texto += String.format("\tIdleness of processing resources = %g %%\n", globais.getOciosidadeCompuacao());
        texto += String.format("\tIdleness of communication resources = %g %%\n", globais.getOciosidadeComunicacao());
        texto += String.format("\tEfficiency = %g %%\n", globais.getEficiencia());
        if (globais.getEficiencia() > 70.0) {
            texto += "\tEfficiency GOOD\n ";
        } else if (globais.getEficiencia() > 40.0) {
            texto += "\tEfficiency MEDIA\n ";
        } else {
            texto += "\tEfficiency BAD\n ";
        }
        return texto;
    }

    private String getResultadosTarefas(List<Tarefa> tarefas) {
        String texto = "\n\n\t\tTASKS\n ";
        double tempoMedioFilaComunicacao = 0;
        double tempoMedioComunicacao = 0;
        double tempoMedioSistemaComunicacao;
        double tempoMedioFilaProcessamento = 0;
        double tempoMedioProcessamento = 0;
        double tempoMedioSistemaProcessamento;

        int numTarefasCanceladas = 0;
        double MflopsDesperdicio = 0;
        int numTarefas = 0;



        for (Tarefa no : tarefas) {
            if (no.getEstado() == Tarefa.CONCLUIDO) {
                tempoMedioFilaComunicacao += no.getMetricas().getTempoEsperaComu();
                tempoMedioComunicacao += no.getMetricas().getTempoComunicacao();
                tempoMedioFilaProcessamento = no.getMetricas().getTempoEsperaProc();
                tempoMedioProcessamento = no.getMetricas().getTempoProcessamento();
                numTarefas++;

            } else if (no.getEstado() == Tarefa.CANCELADO) {
                MflopsDesperdicio += no.getTamProcessamento() * no.getMflopsProcessado();
                numTarefasCanceladas++;
            }




            CS_Processamento temp = (CS_Processamento) no.getLocalProcessamento();
            temp.setTempoProcessamento(no.getTempoInicial(), no.getTempoFinal());


        }

        tempoMedioFilaComunicacao = tempoMedioFilaComunicacao / numTarefas;
        tempoMedioComunicacao = tempoMedioComunicacao / numTarefas;
        tempoMedioFilaProcessamento = tempoMedioFilaProcessamento / numTarefas;
        tempoMedioProcessamento = tempoMedioProcessamento / numTarefas;
        tempoMedioSistemaComunicacao = tempoMedioFilaComunicacao + tempoMedioComunicacao;
        tempoMedioSistemaProcessamento = tempoMedioFilaProcessamento + tempoMedioProcessamento;
        texto += "\n Communication \n";
        texto += String.format("    Queue average time: %g seconds.\n", tempoMedioFilaComunicacao);
        texto += String.format("    Communication average time: %g seconds.\n", tempoMedioComunicacao);
        texto += String.format("    System average time: %g seconds.\n", tempoMedioSistemaComunicacao);
        texto += "\n Processing \n";
        texto += String.format("    Queue average time: %g seconds.\n", tempoMedioFilaProcessamento);
        texto += String.format("    Processing average time: %g seconds.\n", tempoMedioProcessamento);
        texto += String.format("    System average time: %g seconds.\n", tempoMedioSistemaProcessamento);
        if (numTarefasCanceladas > 0) {
            texto += "\n Tasks Canceled \n";
            texto += String.format("    Number: %d \n", numTarefasCanceladas);
            texto += String.format("    Wasted Processing: %g Mflops", MflopsDesperdicio);
        }
        return texto;
    }

    private Object[][] setTabelaRecurso(RedeDeFilas rdf) {
        List<String> recurso = new ArrayList<String>();
        List<Object[]> tabela = new ArrayList<Object[]>();
        //linha [Nome] [Proprietario] [Processamento] [comunicacao]
        String nome;
        String prop;
        Double proc;
        Double comu;
        if (rdf.getMestres() != null) {
            for (CS_Processamento mestre : rdf.getMestres()) {
                if (recurso.contains(mestre.getId())) {
                    int i = 0;
                    while (!tabela.get(i)[0].equals(mestre.getId())) {
                        i++;
                    }
                    tabela.get(i)[2] = (Double) tabela.get(i)[2] + mestre.getMetrica().getSegundosDeProcessamento();
                } else {
                    nome = mestre.getId();
                    prop = mestre.getProprietario();
                    proc = mestre.getMetrica().getSegundosDeProcessamento();
                    comu = 0.0;
                    tabela.add(Arrays.asList(nome, prop, proc, comu).toArray());
                    recurso.add(mestre.getId());
                }
            }
        }
        if (rdf.getMaquinas() != null) {
            for (CS_Processamento maq : rdf.getMaquinas()) {
                if (recurso.contains(maq.getId())) {
                    int i = 0;
                    while (!tabela.get(i)[0].equals(maq.getId())) {
                        i++;
                    }
                    proc = maq.getMetrica().getSegundosDeProcessamento();
                    proc += Double.valueOf(tabela.get(i)[2].toString());
                    tabela.get(i)[2] = proc;
                } else {
                    nome = maq.getId();
                    prop = maq.getProprietario();
                    proc = maq.getMetrica().getSegundosDeProcessamento();
                    comu = 0.0;
                    tabela.add(Arrays.asList(nome, prop, proc, comu).toArray());
                    recurso.add(maq.getId());
                }
            }
        }
        if (rdf.getInternets() != null) {
            for (CS_Comunicacao net : rdf.getInternets()) {
                nome = net.getId();
                prop = "---";
                proc = 0.0;
                comu = net.getMetrica().getSegundosDeTransmissao();
                tabela.add(Arrays.asList(nome, prop, proc, comu).toArray());
            }
        }
        if (rdf.getLinks() != null) {
            for (CS_Comunicacao link : rdf.getLinks()) {
                nome = link.getId();
                prop = "---";
                proc = 0.0;
                comu = link.getMetrica().getSegundosDeTransmissao();
                tabela.add(Arrays.asList(nome, prop, proc, comu).toArray());
                recurso.add(link.getId());
            }
        }
        Object[][] temp = new Object[tabela.size()][4];
        for (int i = 0; i < tabela.size(); i++) {
            temp[i] = tabela.get(i);
        }
        return temp;
    }

    private JFreeChart criarGraficoProcessamentoTempoUser(List<Tarefa> tarefas, RedeDeFilas rdf) {

        List<List> lista = new LinkedList<List>();
        XYSeriesCollection dadosGrafico = new XYSeriesCollection();
        Double acumulado = 0.0000;
        int k, aux;
        int i, j;

        if (!tarefas.isEmpty()) {

            for (i = 0; i < rdf.getMetricasUsuarios().getUsuarios().size(); i++) {

                List<tempo_uso_usuario> temp = new LinkedList<tempo_uso_usuario>();


                for (Tarefa task : tarefas) {
                    if (task.getProprietario().equals(rdf.getMetricasUsuarios().getUsuarios().get(i))) {

                        CS_Processamento local = (CS_Processamento) task.getLocalProcessamento();
                        Double uso = (local.getPoderComputacional() / this.poderComputacionalTotal) * 100;

                        //tempo_uso_usuario provisorio1 = new tempo_uso_usuario(task.getTempoInicial(),true,uso);
                        //tempo_uso_usuario provisorio2 = new tempo_uso_usuario(task.getTempoFinal(),false,uso);



                        for (k = 0; k < temp.size(); k++) {
                            if (temp.get(k).get_tempo() >= task.getTempoInicial()) {
                                break;
                            }

                        }
                        tempo_uso_usuario provisorio1 = new tempo_uso_usuario(task.getTempoInicial(), true, uso);

                        temp.add(k, provisorio1);

                        for (k = 0; k < temp.size(); k++) {
                            if (temp.get(k).get_tempo() >= task.getTempoFinal()) {
                                break;
                            }
                        }
                        tempo_uso_usuario provisorio2 = new tempo_uso_usuario(task.getTempoFinal(), false, uso);
                        temp.add(k, provisorio2);

                    }
                }
                lista.add(temp);

            }

        }




        for (i = 0; i < lista.size(); i++) {
            XYSeries tmp_series = new XYSeries(rdf.getMetricasUsuarios().getUsuarios().get(i));
            for (j = 0; j < lista.get(i).size(); j++) {
                tempo_uso_usuario temp = (tempo_uso_usuario) lista.get(i).get(j);
                if (j == 0) {
                    acumulado = temp.get_uso_no();
                    tmp_series.add(temp.get_tempo(), acumulado);
                } else {
                    tmp_series.add(temp.get_tempo(), acumulado);
                    if (temp.get_tipo()) {
                        acumulado += temp.get_uso_no();
                    } else {
                        acumulado -= temp.get_uso_no();
                    }

                    tmp_series.add(temp.get_tempo(), acumulado);
                }



                //System.out.println(rdf.getMetricasUsuarios().getUsuarios().get(i)+temp.tempo+","+temp.uso_no);
            }
            dadosGrafico.addSeries(tmp_series);
        }

        JFreeChart jfreechart = ChartFactory.createXYLineChart(
                "Use of total computing power through time"
                + "\nUsers", //Titulo,
                "Time (seconds)", // Eixo X
                "Rate of total use of computing power (%)", //Eixo Y
                dadosGrafico, PlotOrientation.VERTICAL, true, true, false);
        XYPlot xyplot = (XYPlot) jfreechart.getPlot();
        xyplot.setDomainPannable(true);
        XYStepAreaRenderer xysteparearenderer = new XYStepAreaRenderer(2);
        xysteparearenderer.setDataBoundsIncludesVisibleSeriesOnly(false);
        xysteparearenderer.setBaseToolTipGenerator(new StandardXYToolTipGenerator());
        xysteparearenderer.setDefaultEntityRadius(6);
        xyplot.setRenderer(xysteparearenderer);
        return jfreechart;
    }

    private JFreeChart criarGraficoProcessamento(RedeDeFilas rdf) {
        DefaultCategoryDataset dadosGrafico = new DefaultCategoryDataset();
        List<String> maqNomes = new ArrayList<String>();
        if (rdf.getMestres() != null) {
            for (CS_Processamento mst : rdf.getMestres()) {
                dadosGrafico.addValue(mst.getMetrica().getMFlopsProcessados(), "vermelho", mst.getId());
                maqNomes.add(mst.getId());
            }
        }
        if (rdf.getMaquinas() != null) {
            for (CS_Processamento maq : rdf.getMaquinas()) {
                if (maqNomes.contains(maq.getId())) {
                    Double valor = (Double) dadosGrafico.getValue("vermelho", maq.getId());
                    valor += maq.getMetrica().getMFlopsProcessados();
                    dadosGrafico.setValue(valor, "vermelho", maq.getId());
                } else {
                    dadosGrafico.addValue(maq.getMetrica().getMFlopsProcessados(), "vermelho", maq.getId());
                    maqNomes.add(maq.getId());
                }
            }
        }
        JFreeChart jfc = ChartFactory.createBarChart(
                "Total processed on each resource", //Titulo
                "Resource", // Eixo X
                "Mflops", //Eixo Y
                dadosGrafico, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                false, false, false); // exibir: legendas, tooltips, url
        return jfc;
    }

    private JFreeChart criarGraficoProcessamentoTempoTarefa(List<Tarefa> tarefas) {

        XYSeriesCollection dadosGrafico = new XYSeriesCollection();
        if (!tarefas.isEmpty()) {
            int i = 0;
            for (Tarefa task : tarefas) {

                XYSeries tmp_series;
                tmp_series = new XYSeries("task " + tarefas.get(i).getIdentificador());
                CS_Processamento temp = (CS_Processamento) task.getLocalProcessamento();

                Double uso = (temp.getPoderComputacional() / this.poderComputacionalTotal) * 100;
                //System.out.println("tamanho_tarefas = "+tarefas.get(i).getTamProcessamento());
                //System.out.println("soma = "+this.soma_poder.getSoma());
                tmp_series.add(tarefas.get(i).getTempoInicial(), uso);

                tmp_series.add(tarefas.get(i).getTempoFinal(), uso);
                i++;
                dadosGrafico.addSeries(tmp_series);
            }


        }

        JFreeChart jfc = ChartFactory.createXYAreaChart(
                "Use of total computing power through time "
                + "\nTasks", //Titulo
                "Time (seconds)", // Eixo X
                "Rate of total use of computing power (%)", //Eixo Y
                dadosGrafico, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                true, true, false); // exibir: legendas, tooltips, url
        return jfc;
    }

    //Cria o gráfico que demonstra o uso de cada recurso do sistema através do tempo.
    //Ele recebe como parâmetro a lista com as maquinas que processaram durante a simulação.
    private JFreeChart criarGraficoProcessamentoTempo(RedeDeFilas rdf) {
        XYSeriesCollection dadosGrafico = new XYSeriesCollection();


        //Se tiver alguma máquina na lista.
        if (rdf.getMaquinas() != null) {
            //Laço foreach que percorre as máquinas.
            for (CS_Processamento maq : rdf.getMaquinas()) {
                //Lista que recebe os pares de intervalo de tempo em que a máquina executou.
                LinkedList<ParesOrdenadosUso> lista = maq.getListaProcessamento();

                poderComputacionalTotal += (maq.getPoderComputacional() - (maq.getOcupacao() * maq.getPoderComputacional()));
                //Se a máquina tiver intervalos.
                if (!lista.isEmpty()) {
                    //Cria o objeto do tipo XYSeries.
                    XYSeries tmp_series;
                    //Se o atributo numeroMaquina for 0, ou seja, não for um nó de um cluster.
                    if (maq.getnumeroMaquina() == 0) //Estancia com o nome puro.
                    {
                        tmp_series = new XYSeries(maq.getId());
                    } //Se for 1 ou mais, ou seja, é um nó de cluster.
                    else //Estancia tmp_series com o nome concatenado com a palavra node e seu numero.
                    {
                        tmp_series = new XYSeries(maq.getId() + " node " + maq.getnumeroMaquina());
                    }

                    int i;
                    //Laço que vai adicionando os pontos para a criação do gráfico.
                    for (i = 0; i < lista.size(); i++) {
                        //Calcula o uso, que é 100% - taxa de ocupação inicial.
                        Double uso = 100 - (maq.getOcupacao() * 100);
                        //Adiciona ponto inicial.
                        tmp_series.add(lista.get(i).getInicio(), uso);

                        //System.out.println(lista.get(i).getInicio()+" uso-> "+uso);
                        //Adiciona ponto final.
                        tmp_series.add(lista.get(i).getFim(), uso);

                        //System.out.println(lista.get(i).getFim()+" uso-> "+uso);

                        if (i + 1 != lista.size()) {
                            uso = 0.0000;
                            tmp_series.add(lista.get(i).getFim(), uso);

                            //System.out.println(lista.get(i).getFim()+" uso-> "+uso);
                            tmp_series.add(lista.get(i + 1).getInicio(), uso);
                            //System.out.println(lista.get(i+1).getInicio()+" uso-> "+uso);
                        }


                    }
                    //Add no gráfico.
                    dadosGrafico.addSeries(tmp_series);
                }

            }


        }

        JFreeChart jfc = ChartFactory.createXYAreaChart(
                "Use of computing power through time "
                + "\nMachines", //Titulo
                "Time (seconds)", // Eixo X
                "Rate of use of computing power for each node (%)", //Eixo Y
                dadosGrafico, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                true, true, false); // exibir: legendas, tooltips, url
        return jfc;
    }

    private JFreeChart criarGraficoComunicacao(RedeDeFilas rdf) {
        DefaultCategoryDataset dadosGrafico = new DefaultCategoryDataset();
        if (rdf.getLinks() != null) {
            for (CS_Comunicacao link : rdf.getLinks()) {
                dadosGrafico.addValue(link.getMetrica().getMbitsTransmitidos(), "vermelho", link.getId());
            }
        }
        if (rdf.getInternets() != null) {
            for (CS_Comunicacao net : rdf.getInternets()) {
                dadosGrafico.addValue(net.getMetrica().getMbitsTransmitidos(), "vermelho", net.getId());
            }
        }
        JFreeChart jfc = ChartFactory.createBarChart(
                "Total communication in each resource", //Titulo
                "Resource", // Eixo X
                "Mbits", //Eixo Y
                dadosGrafico, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                false, false, false); // exibir: legendas, tooltips, url
        return jfc;
    }

    private JFreeChart criarGraficoPizzaProcessamento(RedeDeFilas rdf) {
        DefaultPieDataset dadosGrafico = new DefaultPieDataset();
        List<String> maqNomes = new ArrayList<String>();
        if (rdf.getMestres() != null) {
            for (CS_Processamento mst : rdf.getMestres()) {
                dadosGrafico.insertValue(0, mst.getId(), mst.getMetrica().getMFlopsProcessados());
                maqNomes.add(mst.getId());
            }
        }
        if (rdf.getMaquinas() != null) {
            for (CS_Processamento maq : rdf.getMaquinas()) {
                if (maqNomes.contains(maq.getId())) {
                    Double valor = (Double) dadosGrafico.getValue(maq.getId());
                    valor += maq.getMetrica().getMFlopsProcessados();
                    dadosGrafico.setValue(maq.getId(), valor);
                } else {
                    dadosGrafico.insertValue(0, maq.getId(), maq.getMetrica().getMFlopsProcessados());
                    maqNomes.add(maq.getId());
                }
            }
        }
        JFreeChart jfc = ChartFactory.createPieChart(
                "Total processed on each resource", //Titulo
                dadosGrafico, // Dados para o grafico
                true, false, false);
        return jfc;
    }

    private JFreeChart criarGraficoPizzaComunicacao(RedeDeFilas rdf) {
        DefaultPieDataset dadosGrafico = new DefaultPieDataset();
        if (rdf.getLinks() != null) {
            for (CS_Comunicacao link : rdf.getLinks()) {
                dadosGrafico.insertValue(0, link.getId(), link.getMetrica().getMbitsTransmitidos());
            }
        }
        if (rdf.getInternets() != null) {
            for (CS_Comunicacao net : rdf.getInternets()) {
                dadosGrafico.insertValue(0, net.getId(), net.getMetrica().getMbitsTransmitidos());
            }
        }
        JFreeChart jfc = ChartFactory.createPieChart(
                "Total communication in each resource", //Titulo
                dadosGrafico, // Dados para o grafico
                true, false, false);
        return jfc;
    }

    private void setResultadosUsuario(MetricasUsuarios metricasUsuarios) {
        if (metricasUsuarios.getUsuarios().size() > 1) {
            String texto = "";
            for (int i = 0; i < metricasUsuarios.getUsuarios().size(); i++) {
                String userName = metricasUsuarios.getUsuarios().get(i);
                texto += "\n\n\t\tUser " + userName + "\n";
                texto += "\nNumber of task: " + metricasUsuarios.getTarefasConcluidas(userName).size() + "\n";
                //Applications:
                //Name: Number of task: Mflops:
                double tempoMedioFilaComunicacao = 0;
                double tempoMedioComunicacao = 0;
                double tempoMedioSistemaComunicacao;
                double tempoMedioFilaProcessamento = 0;
                double tempoMedioProcessamento = 0;
                double tempoMedioSistemaProcessamento;
                int numTarefasCanceladas = 0;
                int numTarefas = 0;
                for (Tarefa no : metricasUsuarios.getTarefasConcluidas(userName)) {
                    tempoMedioFilaComunicacao += no.getMetricas().getTempoEsperaComu();
                    tempoMedioComunicacao += no.getMetricas().getTempoComunicacao();
                    tempoMedioFilaProcessamento = no.getMetricas().getTempoEsperaProc();
                    tempoMedioProcessamento = no.getMetricas().getTempoProcessamento();
                    numTarefas++;
                }
                tempoMedioFilaComunicacao = tempoMedioFilaComunicacao / numTarefas;
                tempoMedioComunicacao = tempoMedioComunicacao / numTarefas;
                tempoMedioFilaProcessamento = tempoMedioFilaProcessamento / numTarefas;
                tempoMedioProcessamento = tempoMedioProcessamento / numTarefas;
                tempoMedioSistemaComunicacao = tempoMedioFilaComunicacao + tempoMedioComunicacao;
                tempoMedioSistemaProcessamento = tempoMedioFilaProcessamento + tempoMedioProcessamento;
                texto += "\n Communication \n";
                texto += String.format("    Queue average time: %g seconds.\n", tempoMedioFilaComunicacao);
                texto += String.format("    Communication average time: %g seconds.\n", tempoMedioComunicacao);
                texto += String.format("    System average time: %g seconds.\n", tempoMedioSistemaComunicacao);
                texto += "\n Processing \n";
                texto += String.format("    Queue average time: %g seconds.\n", tempoMedioFilaProcessamento);
                texto += String.format("    Processing average time: %g seconds.\n", tempoMedioProcessamento);
                texto += String.format("    System average time: %g seconds.\n", tempoMedioSistemaProcessamento);
            }
            jTextAreaUsuario.setText(texto);
        } else {
            jTabbedPane1.remove(jScrollPaneUsuario);
        }
    }

    private void gerarGraficosComunicacao(RedeDeFilas rdf) {
        DefaultCategoryDataset dadosGraficoComunicacao = new DefaultCategoryDataset();
        DefaultPieDataset dadosGraficoPizzaComunicacao = new DefaultPieDataset();

        if (rdf.getLinks() != null) {
            for (CS_Comunicacao link : rdf.getLinks()) {
                dadosGraficoComunicacao.addValue(link.getMetrica().getMbitsTransmitidos(), "vermelho", link.getId());
                dadosGraficoPizzaComunicacao.insertValue(0, link.getId(), link.getMetrica().getMbitsTransmitidos());
            }
        }
        if (rdf.getInternets() != null) {
            for (CS_Comunicacao net : rdf.getInternets()) {
                dadosGraficoComunicacao.addValue(net.getMetrica().getMbitsTransmitidos(), "vermelho", net.getId());
                dadosGraficoPizzaComunicacao.insertValue(0, net.getId(), net.getMetrica().getMbitsTransmitidos());
            }
        }

        JFreeChart jfc = ChartFactory.createBarChart(
                "Total communication in each resource", //Titulo
                "Resource", // Eixo X
                "Mbits", //Eixo Y
                dadosGraficoComunicacao, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                false, false, false); // exibir: legendas, tooltips, url
        graficoBarraComunicacao = new ChartPanel(jfc);
        graficoBarraComunicacao.setPreferredSize(new Dimension(600, 300));

        jfc = ChartFactory.createPieChart(
                "Total communication in each resource", //Titulo
                dadosGraficoPizzaComunicacao, // Dados para o grafico
                true, false, false);
        graficoPizzaComunicacao = new ChartPanel(jfc);
        graficoPizzaComunicacao.setPreferredSize(new Dimension(600, 300));
    }

    private void gerarGraficosProcessamento(RedeDeFilas rdf) {
        DefaultCategoryDataset dadosGraficoProcessamento = new DefaultCategoryDataset();
        DefaultPieDataset dadosGraficoPizzaProcessamento = new DefaultPieDataset();

        List<String> maqNomes = new ArrayList<String>();
        if (rdf.getMestres() != null) {
            for (CS_Processamento mst : rdf.getMestres()) {
                dadosGraficoProcessamento.addValue(mst.getMetrica().getMFlopsProcessados(), "vermelho", mst.getId());
                dadosGraficoPizzaProcessamento.insertValue(0, mst.getId(), mst.getMetrica().getMFlopsProcessados());
                maqNomes.add(mst.getId());
            }
        }
        if (rdf.getMaquinas() != null) {
            for (CS_Processamento maq : rdf.getMaquinas()) {
                if (maqNomes.contains(maq.getId())) {
                    Double valor = (Double) dadosGraficoProcessamento.getValue("vermelho", maq.getId());
                    valor += maq.getMetrica().getMFlopsProcessados();
                    dadosGraficoProcessamento.setValue(valor, "vermelho", maq.getId());
                    valor = (Double) dadosGraficoPizzaProcessamento.getValue(maq.getId());
                    valor += maq.getMetrica().getMFlopsProcessados();
                    dadosGraficoPizzaProcessamento.setValue(maq.getId(), valor);
                } else {
                    dadosGraficoProcessamento.addValue(maq.getMetrica().getMFlopsProcessados(), "vermelho", maq.getId());
                    dadosGraficoPizzaProcessamento.insertValue(0, maq.getId(), maq.getMetrica().getMFlopsProcessados());
                    maqNomes.add(maq.getId());
                }
            }
        }

        JFreeChart jfc = ChartFactory.createBarChart(
                "Total processed on each resource", //Titulo
                "Resource", // Eixo X
                "Mflops", //Eixo Y
                dadosGraficoProcessamento, // Dados para o grafico
                PlotOrientation.VERTICAL, //Orientacao do grafico
                false, false, false); // exibir: legendas, tooltips, url
        graficoBarraProcessamento = new ChartPanel(jfc);
        graficoBarraProcessamento.setPreferredSize(new Dimension(600, 300));

        jfc = ChartFactory.createPieChart(
                "Total processed on each resource", //Titulo
                dadosGraficoPizzaProcessamento, // Dados para o grafico
                true, false, false);
        graficoPizzaProcessamento = new ChartPanel(jfc);
        graficoPizzaProcessamento.setPreferredSize(new Dimension(600, 300));

    }

    private class tempo_uso_usuario {

        private Double tempo, uso_no;
        private Boolean tipo;

        public tempo_uso_usuario(Double tempo, Boolean tipo, Double uso) {

            this.tempo = tempo;
            this.uso_no = uso;
            this.tipo = tipo;
        }

        public Double get_tempo() {
            return this.tempo;
        }

        public Boolean get_tipo() {
            return this.tipo;
        }

        public Double get_uso_no() {
            return this.uso_no;
        }
    }
}
