/* Generated By:JavaCC: Do not edit this line. Interpretador.java */
package ispd.arquivo.exportador.gridsim;

import CarregaArqTexto.MostraSaida;
import javax.swing.*;
import javax.swing.filechooser.*;
import java.awt.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.awt.image.*;
import java.net.*;
import javax.imageio.*;
import java.awt.*;
import java.util.HashSet;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import javax.swing.*;
import java.io.*;

class Interpretador implements InterpretadorConstants {

        public boolean verbose;
        private String textoVerbose = "Saida do Verbose:";
        public boolean erroEncontrado = false;
        private HashSet<Interpretador.DescreveIconePrivado> listaIcones = new HashSet<Interpretador.DescreveIconePrivado>();
        private HashSet<String> listaNomes = new HashSet<String>();
        private HashSet<String> listaEscravos = new HashSet<String>();
        private HashSet<String> listaConexoes = new HashSet<String>();
        private List<String> escravos2 = new ArrayList<String>();
        private String proprietario = null;
        private String algoritmo = null;
        private String erros = "Erros encontrados durante o parser do Modelo Iconico:";
        private int numIcones = 0;
        private int numArestas = 0;
        private int numVertices = 0;
        private Boolean cargasConfiguradas = new Boolean(false);;
        private Integer cargasTipoConfiguracao = new Integer(-1);
        private String cargasConfiguracao = new String();
        private int numeroConexoes = 0;
        private int tam_comp = 0;
        private int tam_comm = 0;
        private int num_tarefas = 0;

        public Interpretador(){
        }
    

        public void printv(String msg){
                textoVerbose = textoVerbose+"\u005cn>"+msg;
        }

        public void addErro(String msg){
                erros = erros+"\u005cn"+msg;
        }

        public void resuladoParser(){
                if(erroEncontrado){
                        MostraSaida saida = new MostraSaida("Found Errors",erros);
                        saida.setVisible(true);
                }
                else{
                        //JOptionPane.showOptionDialog(null,"Modelo iconico reconhecido com sucesso","Arquivo Reconhecido", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null);
                        if(verbose){ MostraSaida saida = new MostraSaida("Saida do Reconhecimento",textoVerbose); saida.setVisible(true); }
                }
        }

        public void verificaLabels(){
                for(String temp:listaEscravos){
                        if(!listaNomes.contains(temp)){
                                erroEncontrado = true;
                                addErro("\u005c'"+temp+"\u005c' does not exist!");
                        }
                }
                for(String temp:listaConexoes){
                        if(!listaNomes.contains(temp)){
                                erroEncontrado = true;
                                addErro("\u005c'"+temp+"\u005c' does not exist!");
                        }
                }
        }

        public void escreveArquivo(int totalGridlet){
            int i=0, j=0; //i,j => contadores
            try{
                        File file = new File("ModeloGridSim");
                        FileWriter writer = new FileWriter(file);
                        PrintWriter saida = new PrintWriter(writer,true);
                        /*-------------------------------------------------------------------------------------------------------------*/
                        saida.println("import java.util.*; \u005cn import java.Calendar.*; \u005cn import java.gridsim.*; \u005cn import gridsim.net.*;");
                        saida.println("class Modelo \u005cn {");
                        saida.println("public static void main(String[] args) {");
                        saida.println("try {");
                        saida.println("Calendar calendar = Calendar.getInstance();");
                        saida.println("String[] exclude_from_file = {\u005c"\u005c"}; \u005cn String[] exclude_from_processing = {\u005c"\u005c"};");
                        saida.println("GridSim.init(0, calendar, true, exclude_from_file,exclude_from_processing, null);");
                        saida.println("MachineList mList = new MachineList();");

                        //encontrar totalresourse é nº total de recursos
                        saida.println("ArrayList resList = new ArrayList(totalResource);");
                        for(Interpretador.DescreveIconePrivado icone:listaIcones){ //O recurso é uma só máquina.
                                if(icone.getTipoIcone()==1) //Icone é um nó(1)
                                {       saida.println("mList"+i+".add( new Machine("+ i +",1,"+ icone.getPoderComputacional()+"));");
                                        saida.println("ResourceCharacteristics resConfig"+i+" = new ResourceCharacteristics(\u005c"Sun Ultra\u005c",\u005c"Solaris\u005c" , mList"+i+", ResourceCharacteristics.TIME_SHARED, 0, 0);");
                                        saida.println("GridResource "+ icone.getNome() +" = new GridResource(\u005c"name\u005c" , baud_rate, seed, resConfig"+i+", 0.0 , 0.0, 0.0, Weekends,Holidays);");
                                        saida.println("resList.add( "+ icone.getNome() +");");

                                        saida.println("Router "+icone.getNome()+" = new RIPRouter(router"+i+", trace_flag);");
                                        saida.println("FIFOScheduler resSched = new FIFOScheduler(GridResSched_"+i+");");
                                        saida.println(icone.getNome() +".attachHost("+icone.getNome()+", resSched); "); //nome roteador igual ao recurso		
                                        i++;

                                }
                        }

                        for(Interpretador.DescreveIconePrivado icone:listaIcones){ //O recurso é homogeneo, .
                                int k;
                                if(icone.getTipoIcone()==3) //Icone é um cluster(1)
                                {       for(k=0; k< icone.getNumeroEscravos(); k++)
                                        saida.println("mList"+j+".add( new Machine("+ k +",1,"+ icone.getPoderComputacional()+"));");

                                        saida.println("ResourceCharacteristics resConfig"+j+" = new ResourceCharacteristics(\u005c"Sun Ultra\u005c",\u005c"Solaris\u005c" , mList"+j+", ResourceCharacteristics.TIME_SHARED, 0, 0);");
                                        saida.println("GridResource "+ icone.getNome() +" = new GridResource(\u005c"name\u005c" , baud_rate, seed, resConfig"+j+", 0.0 , 0.0, 0.0, Weekends,Holidays);");
                                        saida.println("resList.add( "+ icone.getNome() +");");

                                        saida.println("Router "+icone.getNome()+" = new RIPRouter("+icone.getNome()+", trace_flag);");//nome roteador igual ao recurso
                                        saida.println("FIFOScheduler resSched = new FIFOScheduler(GridResSched_"+i+");");
                                        saida.println(icone.getNome()+".attachHost("+icone.getNome()+", resSched);");

                                }
                        }


                        saida.println("LinkedList<Integer> Weekends = new LinkedList<Integer>(); \u005cn Weekends.add(new Integer(Calendar.SATURDAY)); \u005cn Weekends.add(new Integer(Calendar.SUNDAY)); \u005cn LinkedList<Integer> Holidays = new LinkedList<Integer>();");
                        saida.println("seed=11L*13*17*19*23+1;");

                        saida.println(" GridletList list = new GridletList();");
                        for( i=0; i < num_tarefas; i++)
                        {   if(cargasTipoConfiguracao==0 || cargasTipoConfiguracao==1 ) //Se carga for do tipo Random ou por máquina
                            {   saida.println("Gridlet gridlet"+i+" = new Gridlet("+ i +", "+ tam_comp +", "+ tam_comm * 125000 +", "+ tam_comm * 125000 +");"); //tam_comp em MI, tam_comm está em Mbits é necessário a conversão para bytes.
                                saida.println("list.add(gridlet"+i+");");
                            }
                        }

                        //user jto com comunicação entre grilets

                        totalGridlet = num_tarefas;

                        saida.println("ArrayList userList = new ArrayList(num_user);");
                        saida.println("for (i = 0; i < num_user; i++) ");
                        saida.println("{");
                                // if trace_flag is set to "true", then this experiment will
                                // create User_i.csv where i = 0 ... (num_user-1)
                        saida.println("\u0009NetUser user = new NetUser(User_"+i+", "+totalGridlet+", baud_rate, propDelay, mtu, trace_flag); ");

                                // add a user into a list
                        saida.println("\u0009userList.add(user); ");
                        saida.println("}");

                        saida.println(" NetUser obj = null;");
                        saida.println("for (i = 0; i < userList.size(); i++)");
                        saida.println("{");
                        saida.println("\u0009FIFOScheduler userSched = new FIFOScheduler(NetUserSched_"+i+"); ");
                        saida.println("\u0009obj = (NetUser) userList.get(i);");
                        saida.println("\u0009r_u"+i+".attachHost(obj, userSched); } ");


                        saida.println("FIFOScheduler rSched = new FIFOScheduler(\u005c"r_Sched\u005c");");

                        for(Interpretador.DescreveIconePrivado icone:listaIcones){
                                if(icone.getTipoIcone()==2) //Icone é um link(2)
                                {       saida.println("Link "+ icone.getNome()  +" = new SimpleLink("+ icone.getNome() + ", "+ icone.getBanda() * 1000000 +", "+ icone.getLatencia() * (10^(-3))+", "+icone.getBanda() *0.1 +");");
                                        saida.println(icone.getNoOrigem()+".attachRouter("+icone.getNoDestino()+", link, rSched, rSched);");
                                }

                        }

                        saida.println("GridSim.startGridSimulation();");

                        saida.println("} ");
                        saida.println("\u0009catch (Exception e) ");
                        saida.println(" { ");
                        saida.println("  e.printStackTrace(); ");
                        saida.println("  System.out.println(\u005c"Unwanted errors happen\u005c"); ");
                        saida.println(" }");

                        saida.println(" }");

                        saida.println("class NetUser extends GridSim"); //classe para usuario, 
                        saida.println("\u0009{ ");
                        saida.println("\u0009 private int myId_;    ");  // my entity ID
                        saida.println("\u0009 private String name_;  "); // my entity name
                        saida.println("\u0009 private GridletList list_;     ");     // list of submitted Gridlets
                        saida.println("\u0009 private GridletList receiveList_; ");   // list of received Gridlets
                        saida.println("\u0009 private SimReport report_;");
                        saida.println(" NetUser(String name, int totalGridlet, double baud_rate, double delay,int MTU, boolean trace_flag) throws Exception { super( name, new SimpleLink(name+\u005c"_link\u005c",baud_rate,delay, MTU) ); this.name_ = name; this.receiveList_ = new GridletList(); this.list_ = new GridletList();if (trace_flag == true) {     report_ = new SimReport(name); } this.myId_ = super.getEntityId(name); this.createGridlet(myId_, totalGridlet); } ");

                        //linca o usuario com sua tarefa, falta colocar os parametros
                        saida.println(" public GridletList getGridletList() {  ");
                        saida.println("\u0009return receiveList_; ");
                        saida.println("\u0009} ");

                                                    /**
						     * This method will show you how to create Gridlets
						     * @param userID        owner ID of a Gridlet
						     * @param numGridlet    number of Gridlet to be created
						     */
                        saida.println("\u0009private void createGridlet(int userID, int numGridlet) ");
                        saida.println("\u0009{ ");
                        /*
							int data = 5000;
							for (int i = 0; i < numGridlet; i++)
							{
							    // Creates a Gridlet
							    Gridlet gl = new Gridlet(i, data, data, data);
							    gl.setUserID(userID);

							    // add this gridlet into a list
							    this.list_.add(gl);
							}
						 } 
						public void body()
						    {
							// wait for a little while for about 3 seconds.
							// This to give a time for GridResource entities to register their
							// services to GIS (GridInformationService) entity.
							super.gridSimHold(3.0);
							LinkedList resList = super.getGridResourceList();

							// initialises all the containers
							int totalResource = resList.size();
							int resourceID[] = new int[totalResource];
							String resourceName[] = new String[totalResource];

							// a loop to get all the resources available
							int i = 0;
							for (i = 0; i < totalResource; i++)
							{
							    // Resource list contains list of resource IDs
							    resourceID[i] = ( (Integer) resList.get(i) ).intValue();

							    // get their names as well
							    resourceName[i] = GridSim.getEntityName( resourceID[i] );
							}

							////////////////////////////////////////////////
							// SUBMIT Gridlets

							// determines which GridResource to send to
							int index = myId_ % totalResource;
							if (index >= totalResource) {
							    index = 0;
							}

							// sends all the Gridlets
							Gridlet gl = null;
							boolean success;
							for (i = 0; i < list_.size(); i++)
							{
							    gl = (Gridlet) list_.get(i);
							    write(name_ + "Sending Gridlet #" + i + " to " + resourceName[index]);

							    // For even number of Gridlets, send without an acknowledgement
							    // whether a resource has received them or not.
							    if (i % 2 == 0)
							    {
								// by default - send without an ack
								success = super.gridletSubmit(gl, resourceID[index]);
							    }

							    // For odd number of Gridlets, send with an acknowledgement
							    else
							    {
								// this is a blocking call
								success = super.gridletSubmit(gl,resourceID[index],0.0,true);
								write("ack = " + success + " for Gridlet #" + i);
							    }
							}

							////////////////////////////////////////////////////////
							// RECEIVES Gridlets back

							// hold for few period - few seconds since the Gridlets length are
							// quite huge for a small bandwidth
							super.gridSimHold(5);

							// receives the gridlet back
							for (i = 0; i < list_.size(); i++)
							{
							    gl = (Gridlet) super.receiveEventObject();  // gets the Gridlet
							    receiveList_.add(gl);   // add into the received list

							    write(name_ + ": Receiving Gridlet #" +
								  gl.getGridletID() + " at time = " + GridSim.clock() );
							}

							////////////////////////////////////////////////////////
							// ping functionality
							InfoPacket pkt = null;
							int size = 500;

							// There are 2 ways to ping an entity:
							// a. non-blocking call, i.e.
							//super.ping(resourceID[index], size);    // (i)   ping
							//super.gridSimHold(10);        // (ii)  do something else
							//pkt = super.getPingResult();  // (iii) get the result back

							// b. blocking call, i.e. ping and wait for a result
							pkt = super.pingBlockingCall(resourceID[index], size);

							// print the result
							write("\n-------- " + name_ + " ----------------");
							write(pkt.toString());
							write("-------- " + name_ + " ----------------\n");

							////////////////////////////////////////////////////////
							// shut down I/O ports
							shutdownUserEntity();
							terminateIOEntities();

							// don't forget to close the file
							if (report_ != null) {
							    report_.finalWrite();
							}

							write(this.name_ + ": sending and receiving of Gridlets" + " complete at " + GridSim.clock() ); */
                        saida.println("} ");



                        /*---------------------------------------------------------------------------------------------------------*/
                        saida.close();
                        writer.close();
                        //JOptionPane.showMessageDialog(null,"File successfully saved\n","Completed",JOptionPane.INFORMATION_MESSAGE);
                }
                // em caso de erro apresenta mensagem abaixo  
                catch(Exception e){
                        JOptionPane.showMessageDialog(null,e.getMessage(),"Warning",JOptionPane.WARNING_MESSAGE);
                }


        }

        public void consomeTokens(){
                Token t = getToken(1);
                while( t.kind != MAQ && t.kind != REDE && t.kind != INET && t.kind != CLUSTER && t.kind != CARGA && t.kind != EOF){
                        getNextToken();
                        t = getToken(1);
                }
        }

        public void resetaObjetosParser(){
                textoVerbose = "";
                erroEncontrado = false;
                listaIcones.clear();
                numIcones = 0;
                numVertices = 0;
                numArestas = 0;
                listaNomes.clear();
                listaEscravos.clear();
                listaConexoes.clear();
                escravos2.clear();
                String algoritmo = null;
                String erros = "Foram encontrados os seguintes erros durante o parser:";
                cargasConfiguradas = new Boolean(false);;
                cargasTipoConfiguracao = new Integer(-1);
                cargasConfiguracao = new String();
                numeroConexoes = 0;
                tam_comp = 0;
                tam_comm = 0;
                num_tarefas = 0;
        }

        private class DescreveIconePrivado {

                        private int tipoIcone;
                        private String proprietario;
                        private int IdGlobal;
                        private int IdLocal;
                        private String nome;
                        private int x,y,prex,prey;
                        private double poderComputacional;
                        private double taxaOcupacao;
                        private double latencia;
                        private double banda;
                        private int numeroEscravos;
                        private boolean mestre;
                        private String algoritmoEscalonamento;
                        private List<String> escravos;
                        private List<Integer> escravos2;
                        private int noOrigem;
                        private int noDestino;
                        private String snoOrigem;
                        private String snoDestino;
                        private HashSet<Integer> conexaoEntrada;
                        private HashSet<Integer> conexaoSaida;

                        public DescreveIconePrivado(){
                                conexaoEntrada = new HashSet<Integer>();
                                conexaoSaida = new HashSet<Integer>();
                        }
                        public void setAtributosNo(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double taxaOcupacao,boolean mestre,String algoritmoEscalonamento,List<String> escravos){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = poderComputacional;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = 0.0;
                                this.banda = 0.0;
                                this.mestre = mestre;
                                this.escravos = escravos;
                                this.algoritmoEscalonamento = algoritmoEscalonamento;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }
                        public void setAtributosLink(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda,String snoOrigem, String snoDestino){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = 0.0;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = null;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = snoOrigem;
                                this.snoDestino = snoDestino;
                        }
                        public void setAtributosCluster(int tipoIcone,int IdLocal,int IdGlobal,String nome,double poderComputacional,double latencia,double banda, String algoritmoEscalonamento, int numeroEscravos){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = poderComputacional;
                                this.taxaOcupacao = 0.0;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = algoritmoEscalonamento;
                                this.numeroEscravos = numeroEscravos;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }
                        public void setAtributosInet(int tipoIcone,int IdLocal,int IdGlobal,String nome,double taxaOcupacao,double latencia,double banda){
                                escravos2 = new ArrayList<Integer>();
                                this.tipoIcone = tipoIcone;
                                this.IdLocal = IdLocal;
                                this.IdGlobal = IdGlobal;
                                this.nome = nome;
                                this.x = 0;
                                this.y = 0;
                                this.prex = 0;
                                this.prey = 0;
                                this.poderComputacional = 0.0;
                                this.taxaOcupacao = taxaOcupacao;
                                this.latencia = latencia;
                                this.banda = banda;
                                this.mestre = false;
                                this.escravos = new ArrayList<String>();
                                this.algoritmoEscalonamento = null;
                                this.numeroEscravos = 0;
                                this.noOrigem = 0;
                                this.noDestino = 0;
                                this.snoOrigem = null;
                                this.snoDestino = null;
                        }

                        public void setProprietario(String nome){proprietario=nome;}
                        public void addConexaoEntrada(int num){conexaoEntrada.add(num);}
                        public void addConexaoSaida(int num){conexaoSaida.add(num);}
                        public void addEscravos2(int id){escravos2.add(id);}
                        public int getTipoIcone(){return  tipoIcone;}
                        public int getIdGlobal(){return  IdGlobal;}
                        public int getIdLocal(){return  IdLocal;}
                        public String getNome(){return  nome;}
                        public int getNumX(){return  x;}
                        public int getNumY(){return  y;}
                        public void setX(int x){this.x = x;}
                        public void setY(int y){this.y = y;}
                        public int getNumPreX(){return  prex;}
                        public int getNumPreY(){return  prey;}
                        public void setPreX(int x){this.prex = x;}
                        public void setPreY(int y){this.prey = y;}
                        public double getPoderComputacional(){return  poderComputacional;}
                        public double getTaxaOcupacao(){return  taxaOcupacao;}
                        public double getLatencia(){return  latencia;}
                        public double getBanda(){return  banda;}
                        public boolean getMestre(){return  mestre;}
                        public List<String> getEscravos(){return  escravos;}
                        public List<Integer> getEscravos2(){return  escravos2;}
                        public String getAlgoritmo(){return  algoritmoEscalonamento;}
                        public int getNumeroEscravos(){return numeroEscravos;}
                        public void setNoOrigem(int no){this.noOrigem = no;}
                        public void setNoDestino(int no){this.noDestino = no;}
                        public int getNoOrigem(){return noOrigem;}
                        public int getNoDestino(){return noDestino;}
                        public String getSNoOrigem(){return snoOrigem;}
                        public String getSNoDestino(){return snoDestino;}
                        public HashSet<Integer> getConexaoEntrada(){return conexaoEntrada;}
                        public HashSet<Integer> getConexaoSaida(){return conexaoSaida;}
        }

  final public void Modelo() throws ParseException {
        resetaObjetosParser();
    try {
      Icones();
      jj_consume_token(0);
                        printv("Reconheceu Modelo()");

                        verificaLabels();

                        resuladoParser();
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
                resuladoParser();
    }
  }

  final public void Icones() throws ParseException {
    label_1:
    while (true) {
      Icone();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAQ:
      case REDE:
      case INET:
      case CARGA:
      case CLUSTER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
                  printv("Reconheceu Icones");
  }

  final public void Icone() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAQ:
      No();
                  printv("Reconheceu No()");
      break;
    case CLUSTER:
      Cluster();
                  printv("Reconheceu Cluster()");
      break;
    case REDE:
      Link();
                  printv("Reconheceu Link()");
      break;
    case INET:
      Inet();
                  printv("Reconheceu Inet()");
      break;
    case CARGA:
      Carga();
                  printv("Reconheceu Carga()");
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public boolean NoTipo() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MESTRE:
      jj_consume_token(MESTRE);
      algoritmo = ClusterAlg();
      jj_consume_token(LMAQ);
      NoLista();
                                                           {if (true) return true;}
      break;
    case ESCRAVO:
      jj_consume_token(ESCRAVO);
                      {if (true) return false;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean TipoUsuario() throws ParseException {
        Token t;
        Boolean mestre;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case nome:
      t = jj_consume_token(nome);
      mestre = NoTipo();
                                   proprietario = t.image; {if (true) return mestre;}
      break;
    case MESTRE:
    case ESCRAVO:
      mestre = NoTipo();
                          proprietario = null; {if (true) return mestre;}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NoLista() throws ParseException {
        Token t;
        String s;
        escravos2.clear();
    label_2:
    while (true) {
      t = jj_consume_token(nome);
                  s = t.image; escravos2.add(s); listaEscravos.add(s); printv("Reconheceu nome no escravo");
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case nome:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
    }
  }

  final public void No() throws ParseException {
        Boolean mestre;
        Token t2, t3, t4;
        DescreveIconePrivado icone = new DescreveIconePrivado();
        List<String> escravos = new ArrayList<String>();
    try {
      jj_consume_token(MAQ);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      mestre = TipoUsuario();
                        icone.setProprietario(proprietario);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }

                        if(mestre){icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), true, algoritmo, escravos2);
                                        listaIcones.add(icone);
                                        numIcones++;
                                        numVertices++;
                                        algoritmo = null;
                                }
                        else{icone.setAtributosNo(1, numVertices, numIcones, t2.image, Double.parseDouble(t3.image), Double.parseDouble(t4.image), false, algoritmo, escravos);
                                        listaIcones.add(icone);
                                        numIcones++;
                                        numVertices++;
                                }
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Link() throws ParseException {
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
    try {
      jj_consume_token(REDE);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
      jj_consume_token(CONECTA);
      t6 = jj_consume_token(nome);
      t7 = jj_consume_token(nome);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }

                        if(!listaConexoes.contains(t6.image)){ listaConexoes.add(t6.image); }
                        if(!listaConexoes.contains(t7.image)){ listaConexoes.add(t7.image); }
                        icone.setAtributosLink(2, numArestas, numIcones , t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image), t6.image, t7.image);
                        listaIcones.add(icone);
                        numArestas++;
                        numIcones++;
                        numeroConexoes++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public String ClusterAlg() throws ParseException {
        Token t;
        String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RR:
      t = jj_consume_token(RR);
                 s = t.image; {if (true) return s;}
      break;
    case WORKQUEUE:
      t = jj_consume_token(WORKQUEUE);
                          s = t.image; {if (true) return s;}
      break;
    case FPLTF:
      t = jj_consume_token(FPLTF);
                      s = t.image; {if (true) return s;}
      break;
    case VAZIO:
      t = jj_consume_token(VAZIO);
                      s = t.image; {if (true) return s;}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String TipoUsuarioCluster() throws ParseException {
        Token t;
        String alg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case nome:
      t = jj_consume_token(nome);
      alg = ClusterAlg();
                                    proprietario = t.image; {if (true) return alg;}
      break;
    case RR:
    case VAZIO:
    case FPLTF:
    case WORKQUEUE:
      alg = ClusterAlg();
                           proprietario = null; {if (true) return alg;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Cluster() throws ParseException {
        String s;
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
    try {
      jj_consume_token(CLUSTER);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(inteiro);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
      t6 = jj_consume_token(flutuante);
      s = TipoUsuarioCluster();
                        icone.setProprietario(proprietario);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }
                        icone.setAtributosCluster(3, numVertices, numIcones, t2.image, Double.parseDouble(t4.image), Double.parseDouble(t6.image), Double.parseDouble(t5.image), s,  Integer.parseInt(t3.image));
                        listaIcones.add(icone);
                        numIcones++;
                        numVertices++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Inet() throws ParseException {
        Token t2, t3, t4, t5, t6, t7;
        DescreveIconePrivado icone = new DescreveIconePrivado();
        //escravos.clear();
        HashSet<String> nosConectados = new HashSet<String>();
        List<String> escravos = new ArrayList<String>();
    try {
      jj_consume_token(INET);
      t2 = jj_consume_token(nome);
      t3 = jj_consume_token(flutuante);
      t4 = jj_consume_token(flutuante);
      t5 = jj_consume_token(flutuante);
                        if(listaNomes.contains(t2.image)){
                                addErro("There's already an icon named \u005c'"+t2.image+"\u005c'.");
                                erroEncontrado = true;
                        }else{
                                listaNomes.add(t2.image);
                        }
                        icone.setAtributosInet(4, numVertices,numIcones, t2.image, Double.parseDouble(t5.image), Double.parseDouble(t4.image), Double.parseDouble(t3.image));
                        listaIcones.add(icone);
                        numIcones++;
                        numVertices++;
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void Carga() throws ParseException {
        cargasConfiguradas = true;
    try {
      jj_consume_token(CARGA);
      TipoCarga();
    } catch (ParseException e) {
                Token t = getToken(1);
                addErro("Erro semantico encontrado na linha "+t.endLine+", coluna "+t.endColumn);
                erroEncontrado = true;
                consomeTokens();
    }
  }

  final public void TipoCarga() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANDOM:
      jj_consume_token(RANDOM);
      TipoRandom();
      break;
    case MAQUINA:
      jj_consume_token(MAQUINA);
      label_3:
      while (true) {
        TipoMaquina();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case nome:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
      }
      break;
    case TRACE:
      jj_consume_token(TRACE);
      TipoTrace();
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void TipoRandom() throws ParseException {
        String dist;
        Token t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11;
        cargasTipoConfiguracao = 0;
        num_tarefas = 0;
        tam_comp = 0;
        tam_comm = 0;
    t1 = jj_consume_token(inteiro);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(inteiro);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(inteiro);
    t6 = jj_consume_token(inteiro);
    t7 = jj_consume_token(inteiro);
    t8 = jj_consume_token(flutuante);
    t9 = jj_consume_token(inteiro);
    t10 = jj_consume_token(inteiro);
    t11 = jj_consume_token(inteiro);
                cargasConfiguracao = t1.image+" "+t2.image+" "+t3.image+" "+t4.image+"\u005cn"+t5.image+" "+t6.image+" "+t7.image+" "+t8.image+"\u005cn"+t9.image+" "+t10.image+" "+t11.image;
                num_tarefas = Integer.parseInt(t11.image);
                tam_comp = Integer.parseInt(t2.image);
                tam_comm = Integer.parseInt(t6.image);
  }

  final public String Distribuicao() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POISSON:
      t = jj_consume_token(POISSON);
                             {if (true) return t.image;}
      break;
    case EXPONENCIAL:
      t = jj_consume_token(EXPONENCIAL);
                                 {if (true) return t.image;}
      break;
    case TWOSTAGE:
      t = jj_consume_token(TWOSTAGE);
                              {if (true) return t.image;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TipoMaquina() throws ParseException {
        String dist;
        Token t1,t2,t3,t4,t5,t6;
        cargasTipoConfiguracao = 1;
        num_tarefas = 0;
        tam_comp = 0;
        tam_comm = 0;
    t1 = jj_consume_token(nome);
    t2 = jj_consume_token(inteiro);
    t3 = jj_consume_token(flutuante);
    t4 = jj_consume_token(flutuante);
    t5 = jj_consume_token(flutuante);
    t6 = jj_consume_token(flutuante);
                cargasConfiguracao += ""+t1.image+" "+t2.image+" "+t3.image+" "+t4.image+" "+t5.image+" "+t6.image+"\u005cn";
                num_tarefas = Integer.parseInt(t2.image);
                tam_comp = Integer.parseInt(t3.image);
                tam_comm = Integer.parseInt(t5.image);
  }

  final public void TipoTrace() throws ParseException {
        Token t;
        cargasTipoConfiguracao = 2;
    t = jj_consume_token(nome);
                cargasConfiguracao = t.image+"\u005cn";
  }

  /** Generated Token Manager. */
  public InterpretadorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x4164,0x4164,0x2400,0x202400,0x200000,0x4008a,0x24008a,0x200000,0x10a00,0xa1000,};
   }

  /** Constructor with InputStream. */
  public Interpretador(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Interpretador(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Interpretador(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new InterpretadorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Interpretador(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(InterpretadorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[30];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 30; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
